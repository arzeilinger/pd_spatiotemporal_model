---
title: "Seasonal Pierce's Disease model"
author: "Adam Zeiliinger"
date: "11/6/2019"
output:
  pdf_document: default
  html_document: default
---

```{r set-options, echo=FALSE, cache=FALSE}
options(width = 120)
```

```{r setup, include=FALSE}
my.packages <- c("ggplot2", "raster", "dplyr", "tidyr", "data.table")
lapply(my.packages, require, character.only = TRUE)

#### Source additional functions
## Vector density function
#source("R_functions/seasonal_vector_density_functions.R")
## Dispersal kernel functions, also includes makeCoordinates() function
source("R_functions/dispersal_kernel_functions.R")
source("R_functions/factor2numeric.R")
```

## Host compartments

The model consists of a spatially explicit, discrete-time SEIDS host compartments. Susceptible hosts become infected and move to the Exposed (or latently infected) compartment according to a force of infection $\lambda_{i}(t)$. After a latent period, host i moves into the I, or Infectious, compartment and can now contribute to transmitting the pathogen to other hosts (through vectors). However, hosts in the Infectious compartment are considered asymptomatic. Then after some post-latent incubation period, host i moves into the D, or Diseased, compartment where it remains infectious but now also symptomatic. This framework is based on Parry et al. (2014). In additon, hosts in any infected compartment (E, I, D) can recover and become Susceptible again.

\ 

### Adrakey model for force of infection

At its core, we are modeling the instantaneous force of infection of susceptible plant $i$ in the interval between time $t$ to $t + dt$, $\lambda_{i}(t)$, as a function of secondary or vine-to-vine spread rate $\beta$, dispersal scale parameter $\alpha$, and external or primary rate of infection $\epsilon$:

$$
\begin{align}
\lambda_i(t) &= \beta \sum_{j \in I(t)} K(d_{i,j},\alpha) + \epsilon \\
\ \\
\text{Dispersal kernel function is a normalized negative exponential} \\
\ K(d,\alpha) &= \frac{1}{2 \pi d \alpha} \cdot \exp(-\frac{d}{\alpha}) \\
\end{align}
$$

### Transitions among compartments are stochastic
#### Sellke threshold construction

Assume that each susceptible plant $i$ has a threshold of resistance $Q_{i}$ which are exponentially distributed and independent of each other: $Q_{i}\sim\exp(1)$. The cumulative pressure on plant $i$ by time $t$ is given by: 
$$A_i(t)=\int_{0}^{t}\lambda_{i}(u)du$$
Then plant $i$ becomes latently infected at time $t$ when $Q_{i}=A_{i}(t)$. In this way, we relate the force of infection upon a plant to its infection status in a stochastic manner (Adrakey et al. 2017; Sellke 1983).

#### Infectious and Diseased compartment transitions
The transition from Exposed to Infectious is determined by a plant-specific latent period which is assumed to take the form of a gamma distribution, $t_{i}^I|t_{i}^E \sim gamma(\lambda_{EI}, \nu_{EI})$. Likewise, the transition from Infectious to Diseased is treated the same: $t_{i}^D|t_{i}^I \sim gamma(\lambda_{ID}, \nu_{ID})$. The values for the shape parameters were both set to $\lambda_{EI}, \lambda_{ID} = 4$, while the values of the scale parameters were both set to $\nu_{EI}, \nu_{ID} = 1$. This produces a humped shaped distribution with a mean value of 4 weeks for each time period, meaning that, on average, plants move from Exposed to Diseased in 8 weeks.

```{r, fig.align='center', fig.cap='Gamma distribution for latent period and post-latent incubation period'}

## Durations of stays in Exposed compartment
Exposed_time <- rgamma(900, shape = 4, scale = 1)
hist(Exposed_time)

```


## Incorporating vector density and infectivity

Assume that the external infection rate $\epsilon$ and secondary infection rate $\beta$ are time-dependent functions of vector density and infectivity. This is inspired by Parry et al. (2014), who used a similar model to Adrakey et al., but deviates from their exact formulation.

#### External infection rate:

$$
\begin{align}
\text{Time-dependent external infection rate for plant i} \\
\epsilon_{i}(t) &= \eta \kappa \cdot \rho_{\epsilon}(t) \cdot K(D_{i}, \alpha) \\
\text{where } \rho_{\epsilon}(t) \text{ is a piecwise function as follows}: \\
\rho_{\epsilon}(t)= \left\{
\begin{array}{ll}
  \tilde{\rho}(t) & \tilde{\rho}(t)>0 \\
  \ 0 & otherwise \\
\end{array}
\right. \\
\text{with} \\
\tilde{\rho}(t) &= A \cdot \exp(-\lambda t) \cdot \sin(\phi \pi t) \\
\end{align}
$$

Here, $\eta$ is the vector inoculation rate, $\kappa$ is the proportion of external vectors that are infectious, $K(D_{i},\alpha)$ is the immigrant dispersal kernel function, and $\rho_{\epsilon}(t)$ is the average density (per plant) of immigrating external vectors from border vegetation. The immigrant dispersal kernel function could take an equivalent form as the within-field dispersal function $K(d_{i,j},\alpha)$ or could take a different form. The important difference is that whereas $d_{i,j}$ is the distance from susceptible plant $i$ and infected plant $j$, the distance $D_{i}$ is the distance from plant $i$ to the nearest border of the field. This form assumes that immgrating vectors are more likely to land on a plant near the field border than further inside the field.

```{r}

## Example immigrant vector dispersal
alpha <- 10 # Dispersal parameter

#### Plant spatial coordinates
## Total number of plants (numPlants) = nrow(Coo) = nrc*nrc
nrc <- 50 # Number of rows/columns
Coo <- makeCoordinates(nrc)

## Calculating distance to nearest field border for each plant
borderCoo <- rep(c(1,nrc), each = 2)
borderD <- apply(Coo, 1, function(x) min(sqrt((x - borderCoo)^2))+1)
## Add 1 to the distance; plants on the border are then 1 space from the border and all other plants are shifted accordingly
## Dispersal distances from border
epsilonK <- chooseKernel(d = borderD, alpha = alpha, kernelFunc = "normalized exponential")
qplot(borderD,epsilonK,geom="path", xlab="Distance from border", ylab="K(D,alpha)")

```

\ 
The density of immigrating vectors (per plant), $\rho_{\epsilon}(t)$, takes the form of a damped sine wave. The idea is to replicate the generational peaks of BGSS in the border vegetation observed in North Coast data set. This is a pretty crude phenomenological approach and probably needs more detail. Nonetheless with the right parameter values we can get a good approximation of the dynamics within 1 year. The piecewise element is to ensure that the function doesn't produce negative densities; a value greater than zero could also be specified for the "baseline".

```{r}

vectorDensity <- function(A, lambda_osc, phi, base = 0, time){
  rho <- A*exp(-lambda_osc*time)*sin(phi*pi*time)
  ## set negative numbers to zero
  rho <- ifelse(rho < base, base, rho)
  return(rho)
}

timeVec <- seq(1,52,0.1)
rho_et <- vectorDensity(A = -20, lambda_osc = 0.05, phi = 0.09, base = 0.05, time = timeVec)
qplot(timeVec, rho_et, xlab = "Week", ylab = "Immigrating vector density", geom = "path")

```

\ 

#### Secondary infection rate


$$
\begin{align}
\text{Time-dependent secondary infection rate} \\
\beta(t) &= \eta \kappa_{\beta}(t) \cdot \rho_{\beta}(t) \\
\text{where} \\
\kappa_{\beta}(t) &= \frac{a_{I}I(t-1) + a_{D}D(t-1)}{N} \\
\rho_{\beta}(t) &= (1 - \mu_{v}) \cdot (\rho_{\beta}(t-1) + \rho_{\epsilon}(t-1)) \\
\end{align}
$$

Here, $\eta$ is the same inoculation rate as above. But now $\kappa_{\beta}(t)$ is the time-dependent proportion of in-field vectors infectious, and is a function of the density of Infectious grapevines at the previous time step $\frac{I(t-1)}{N}$, the density of Diseased grapevines at the previous time step $\frac{D(t-1)}{N}$, and compartment-specific acquisition rates, $a_{I}, a_{D}$. The different acquisition rates imply that Diseased grapevines will have greater Xylella populations than Infectious grapevines, so acquisition rates from Diseased grapevines should be greater. The density of in-field vectors, $\rho_{\beta}(t)$, is a function of the density of in-field vectors at the previous time step, $\rho_{\beta}(t-1)$, the density of immigrating vectors at the previous time step, $\rho_{\epsilon}(t-1)$, and the loss rate of vectors, $\mu_{v}$, due to death and emmigration. This assumes that reproduction in field is negligible.

\ 

## Inter-annual processes

At the end of each growing season (i.e., winter), we assume that winter recovery, plant dormancy, plant roguing, and vector overwintering occur instantaeously. This is similar to the assumptions of Daugherty and Almeida (2019), Gruber and Daugherty (2013), and the impulse equations of Rozins and Day (2016). 

#### Winter recovery and dormancy

We assume that the probability of winter recovery for plant $i$, $P_{i}^R$, is a function of infection time ($t$, day of year), specifically the time that it moved into the Exposed compartment during the growing season, according to the functional response from Feil et al. (2003):
$$P_{i}^R = (1 - e^{bt})^{135.9}$$

The recovery probability curve, $P_{i}^R$ can be shifted left or right with the parameter $b$. The default value is $b = -0.045$ from Feil et al. 2003. More negative values shift the curve to the left, meaning that plants with earlier infection times are more likely to recover; less negative values shift the curve to the right, making recovery less likely except for very late infections.


```{r}

hostRecovery <- function(time, b = -0.045){
  ## The curve can be shifted by modifying the value of parameter b
  ## More negative values of b shift curve to the left, less negative values shift to the right.
  ## Default value is estimate from Feil et al. 2003
  (1 - exp(b*time))^135.9
}

timestep <- 1:365
test <- hostRecovery(timestep, b = -0.045)
qplot(x = timestep/7, y = test, geom = "path", xlab = "Week", ylab = "Probability of winter recovery")

```

\ 

Recovery status of plant $i$ is then a random binomial variable with probability $P_{i}^R$. If plant i recovers, it then reverts back to Susceptible. If plant i does not recover it remains in the Exposed compartment (or reverts back to the Exposed compartment if it had moved into the Infectious or Diseased compartments within the year). Starting at the beginning of the next year, plants that remain infected then progress into the Infectious (and Diseased) compartments after a latent or post-latent incubation period, $t_{i}^I, t_{i}^D$. These plants are then considered chronically infected. They are eligible to recover the next winter with very low probability (we could easily exclude them from recovery if we want).

All plants that remain chronically infected and have progressed to the Infectious or Diseased compartments revert back to the Exposed compartment. They then progress into the Infectious and Diseased compartments again after another set of latent and post-latent incubation periods. Currently, new periods, $t_{i}^I, t_{i}^D$, are randomly assigned (according to Gamma distributions, above) each new growing season. This induces year-to-year stochasticity in the progression of plants into the different compartments.

\ 

#### Vector overwintering

At the start of each growing season (t = 1), immigrating vector density, $\rho_{\epsilon}(t)$, is equal to some fraction of in-field vectors at the end of the previous season, $\rho_{\beta}(t = Tmax)$. The fraction of overwintering vectors that survive is 1 - $\mu_{v,\epsilon}$, or the death rate of overwintering vectors. 

Likewise, at the start of each growing season, the natural infectivity of immigrating vectors, $\kappa_{\epsilon}$, is set to the infectivity of in-field vectors at the end of the previous season, $\kappa_{\beta}(t = Tmax)$. We assume that infectious and non-infectious overwintering vectors die at the same rate, so the overall proportion of vectors infectious remains the same from the end of one season to the beginning of the next.

Vector overwintering can be "turned on" or "turned off" with the logical flag "vectorOverwintering".

\ 

#### Roguing and replacing diseased vines

At the end of each growing season, we assume that some total number of sympomatic vines, are removed and replaced with new Susceptible vines. Only plants in the Diseased compartment are eligible for roguing. By setting a total number of vines to be rogued, rather than a proportion of diseased vines, we assume that managers have limited time and resources to rogue. So if the number of disease vines exceeds the number to be rogued, some disease vines are left in the field. In this case, a random sub-sample of Diseased vines revert back to the Susceptible compartment. The total number of vines to be rogued can be varied. Roguing can be "turned off" by setting the variable numPlantsRogued = 0.

\ 

## Running the model

```{r, fig.cap = "Raster map of time to disease of each plant", fig.align="center"}

#### Parameter values
## In this version, epsilon and beta are functions of other parameters, define non-varying parameters here
alpha <- 10 # Dispersal parameter
eta <- 0.5 # Inoculation rate (LAMBDA in Parry et al.)
kappa_e <- 0.6 # Proportion of external vectors infectious
aI <- 0.5 # Acquisition rate from Infectious hosts
aD <- 0.7 # Acquisition rate from Diseased hosts; aD should be >= aI because of Xylella population growth
muv <- 0.3 # In-field loss rate of vectors (due to both death and emigration)
### Parameter values for vectorDensity() damped sine wave
A <- -15 # Initial amplitude
lambda_osc <- 0.05 # Dampening
phi <- 0.09 # Angular frequency
base <- 0.1 # Baseline vector density

#### Winter recovery
recoveryb <- -0.045 # Shifting the recovery curve

#### Winter roguing
numPlantsRogued <- 20 # Total number of plants that can be rogued at the end of each season

#### Vector overwintering
muv_e <- 0.5 # Loss rate of vectors overwintering
vectorOverwintering <- TRUE

## Number of time steps; assume each time step is 1 week
Tmax <- 52
## Number of years
numYears <- 6

#### Plant spatial coordinates
## Total number of plants (numPlants) = nrow(Coo) = nrc*nrc
nrc <- 30
Coo <- makeCoordinates(nrc)

## Calculating distance to nearest field border for each plant
# borderCoo <- rep(c(1,nrc), each = 2)
# borderD <- apply(Coo, 1, function(x) min(sqrt((x - borderCoo)^2))+1)
## Distance from the left border whould just be the 1st coordinate
borderD <- Coo[,1]
## Add 1 to the distance; plants on the border are then 1 space from the border and all other plants are shifted accordingly
## Dispersal distances from border
## When d = 0, normalizedKernel = Inf
epsilonK <- chooseKernel(d = borderD, alpha = alpha, kernelFunc = "normalized exponential")


#### Setting up empty vectors and matrices to track things
## Assumes already created a grid of hosts
## Calculate total number of plants and vector of plant IDs
numPlants <- nrow(Coo)
IDs <- 1:numPlants

#### Set up vectors to track state of each plants
## Exposure times should be a matrix: rows = plants, columns = years
Exp_times <- matrix(Tmax, nrow = numPlants, ncol = numYears)
## Vectors of rho_epsilon(t), rho_beta(t), and beta(t) values
rho_etVec <- rho_btVec <- betaVec <- rep(0, Tmax)
## Matrix of epsilon_i(t) values
epsilonMatrix <- matrix(0, nrow = numPlants, ncol = Tmax)
## Matrix of kappa_b(t) values
kappaMatrix <- matrix(0, nrow = Tmax, ncol = numYears)

#### Start year loop
for(y in 1:numYears){
  ####################################################################################################
  #### Stochastic transitions among host compartments
  ## (Re)set Infection times, Disease times (i.e., time of symptom onset)
  Inf_times <- Disease_times <- rep(Tmax, numPlants)
  ## (Re)set lambda values for each plant
  lambda <- rep(0, numPlants)
  ## (Re)set Sellke thresholds for infection
  Q <- rexp(numPlants, rate = 1)
  #### (re)set stochastic latent and cryptic periods
  ## Parry et al. (2014) assumed cryptic period (I -> D) is gamma distributed
  ## Here, we make a similar assumption for latent period (E -> I)
  ## Assume that each period has an average of 4 weeks
  ## a*s (mean) = 4; a:s (ratio) = 4:1; this ratio produces a humped distribution
  ## Parameterization assumes that time step = 1 week, will need to be adjusted if time step changes
  ## Durations of stays in Exposed compartment
  Et <- rgamma(numPlants, shape = 4, scale = 1)
  ## Durations of stays in Infectious compartment
  It <- rgamma(numPlants, shape = 4, scale = 1)
  #####################################################################################################
  #### Nested for loops of t, Susceptible plants, and Infected plants
  for(t in 1:Tmax){
    ## Each time point, update vectors of infecteds, susceptibles, and their respective indices
    Infected_ind <- which(Inf_times < Tmax)
    Susceptible_ind <- which(Exp_times[,y] == Tmax)
    ## Summaries of infections and susceptibles
    numInfections <- length(Infected_ind)
    numSusceptibles <- length(Susceptible_ind)
    #######################################################################################################
    ## Loop over susceptible plants
    for(iiSusceptible in Susceptible_ind){
      infTimeSusceptible <- Exp_times[iiSusceptible, y]
      CooSusceptible <- Coo[iiSusceptible,1:2]
      ## (Re)set dispersal kernel summation to 0
      m <- 0
      #### Loop over infected plants to get dispersal kernel from each Infected to a given Susceptible
      for(iInfected in Infected_ind) {
        infTimeInfected <- Inf_times[iInfected]
        if(infTimeSusceptible > infTimeInfected) { ## This avoids Target plant being same as Source
          ## Calculate d for each Infected plant
          d <- sum(sqrt((Coo[iInfected,1:2] - CooSusceptible)^2))
          ## Calculate the dispersal kernel based on each d and then sum over all kernels
          ## Using Neri et al. 2014 normalized exponential kernel
          ## When using simple exponential kernel, m becomes too large, lambdaii > 1, and rbinom fails with error
          m <- m + chooseKernel(distance = d, alpha = alpha, kernelFunc = "normalized exponential")
        }
        ## Evaluate if cryptic period is exceeded
        ## Infectious plants become Diseased when time step t exceeds Inf_times + It
        ## Only update Infectious plants that aren't Diseased yet
        if(t >= (infTimeInfected + It[iInfected]) & Disease_times[iInfected] == Tmax){
          if(Disease_times[iInfected] < t){
            warning("Old disease time being updated")
          }
          Disease_times[iInfected] <- runif(1, min = t-1, max = t)
        }
      } # End iInfected loop
      ###############################################################################################
      #### Epsilon calculations
      ## If vectorOverwintering == TRUE and it's the start of the year, external vector infectivity and density....
      ## ...are dependent on in-field infectivity and density at the end of the previous year
      if(vectorOverwintering & t == 1){
        # External vector infectivity equals in-field infectivity at end of previous year, unless it's the start of the first year
        kappa_e_initial <- ifelse(y == 1, 0, kappaMatrix[Tmax, y-1]) 
        ##  Immigrating vector density as damped sine wave plus a fraction of in-field vectors from previous year
        rho_et_initial <- vectorDensity(A = A, lambda_osc = lambda_osc, phi = phi, base = base, time = t) + (1-muv_e)*rho_btVec[Tmax] 
        ## Save rho_et
        rho_etVec[t] <- rho_et_initial
        epsilonti <- eta*kappa_e_initial*rho_et_initial*epsilonK[iiSusceptible]
      } else {
        ## Immigrating vector density as damped sine wave
        rho_et <- vectorDensity(A = A, lambda_osc = lambda_osc, phi = phi, base = base, time = t)
        ## Save rho_et
        rho_etVec[t] <- rho_et
        epsilonti <- eta*kappa_e*rho_et*epsilonK[iiSusceptible]
      }
      ## Save epsilonti
      epsilonMatrix[iiSusceptible, t] <- epsilonti
      ############################################################################################################
      #### Beta calculations
      ## if() statement for start of the year
      if(t == 1){
        rho_bt_tm1 <- 0 # Initial in-field density from previous time step
        rho_et_tm1 <- 0 # Initial immigrating density from previous time step
        kappa_t <- 0 # Initial in-field infectivity
        } else {
        ## Calculating in-field infectivity
        Infecteds_tm1 <- sum(Inf_times < t) # Number of Infectious plants at t-1
        Diseased_tm1 <- sum(Disease_times < t) # Number of Diseased plants at t-1
        kappa_t <- aI*(Infecteds_tm1/numPlants) + aD*(Diseased_tm1/numPlants) # Time-dependent in-field infectivity
        ## Getting vector densities (in-field and immigrating) from previous time step
        rho_bt_tm1 <- rho_btVec[t-1]
        rho_et_tm1 <- rho_etVec[t-1]
      }
      kappaMatrix[t,y] <- kappa_t # Save kappa(t)
      ## In-field vector density
      rho_btVec[t] <- (1 - muv)*(rho_bt_tm1 + rho_et_tm1) # Calculate in-field vector density
      beta_t <- eta*kappa_t*rho_btVec[t] # Calculate beta_t
      betaVec[t] <- beta_t # Save beta_t
      ## Cumulative force of infection for iiSusceptible plant
      lambda[iiSusceptible] <- lambda[iiSusceptible] + beta_t*m + epsilonti
      ## If cumulative lambda (i.e., infection pressure) exceeds Q (i.e., Sellke threshold) plant becomes infected,
      ## then receives an infection time in range [t - 1, t]
      if(lambda[iiSusceptible] >= Q[iiSusceptible]){
        Exp_times[iiSusceptible, y] <- runif(1, min = t-1, max = t)
      }
    } # End iiSusceptible loop
    ########################################################################################
    #### Moving from Exposed to Infectious compartments
    ## Select indices of plants that are in Exposed compartment (but not Infectious compartment yet)
    Exposed_ind <- which(Exp_times[,y] < Tmax & Inf_times == Tmax)
    ## Evaluate if latent period is exceeded
    ## Exposed plants become Infectious when time step t exceeds Exp_times + Et 
    for(iExposed in Exposed_ind){
      if(Inf_times[iExposed] < t){
        warning("Old infection time incorrectly being updated")
      }
      if(t >= Exp_times[iExposed, y] + Et[iExposed]){
        Inf_times[iExposed] <- runif(1, min = t-1, max = t)
      }
    } # End iExposed loop
  } # End t loop
  ###########################################################################################
  #### Winter processes
  ###########################################################################################
  ## If simulation is in it's last year, skip winter processes
  if(y < numYears){
    #### Host recovery
    ## Base host recovery on Exposure time, rather than Infection time
    ## Get all plants that became Exposed; differs from Exposed_ind above
    expIndices <- which(Exp_times[,y] < Tmax)
    recoveryStatus <- probRecovery <- rep(0, length(numPlants))
    for(iExposed in expIndices){
      ## hostRecovery function is based on Feil et al. 2003 equation based on day of year; need to convert to week time step
      probRecovery[iExposed] <- hostRecovery(Exp_times[iExposed, y]*7, b = recoveryb)
      recoveryStatus[iExposed] <- rbinom(1, 1, probRecovery[iExposed])
      ## Make sure recoveryStatus is either 0 or 1
      if(recoveryStatus[iExposed] != 0 & recoveryStatus[iExposed] != 1){
        warning("Something is wrong with recoveryStatus")
      }
      ## For chronic infected plants, set Exp_times for next year to 0
      if(recoveryStatus[iExposed] == 0){
        Exp_times[iExposed, y+1] <- 0
      }
    } # End Recovery iExposed loop 
    ## Check that recovery probability calculations are working correctly
    # recoveryCheck <- cbind(Exp_times[expIndices, c(y, y+1)], probRecovery[expIndices], recoveryStatus[expIndices])
    ###########################################################################################
    #### Roguing (removal) and replanting of diseased hosts
    ## Assume that only Diseased (i.e., symptomatic) plants are eligible for removal...
    ## ... and that all Diseased plants have equal probability of removal.
    ## Assume that managers have are limited by the total number of plants they can rogue and replant, rather than a fraction.
    diseaseIndices <- which(Disease_times < Tmax)
    if(length(diseaseIndices) <= numPlantsRogued){
      ## If all diseased plants are to be rogued
      Exp_times[diseaseIndices, y+1] <- Tmax
    } else {
      ## Get random sub-sample of plants to rogue and replace
      roguedPlantIndices <- sample(diseaseIndices, size = numPlantsRogued, replace = FALSE)
      ## Reset Exposed times to Tmax, making them Susceptible again
      Exp_times[roguedPlantIndices, y+1] <- Tmax
    } # End Roguing 
  } # End Winter if() statement
} # End y loop

#### Produce raster with infection times as values
## Get raster dimensions from Coo
## Coo[,1] = rows or y coord
## Coo[,2] = columns or x coord
CooRows <- Coo[,1]
CooNrows <- length(unique(CooRows))
CooYmn <- min(CooRows)
CooYmx <- max(CooRows)
CooColumns <- Coo[,2]
CooNcols <- length(unique(CooColumns))
CooXmn <- min(CooColumns)
CooXmx <- max(CooColumns)

rasterTimes <- raster(nrows = CooNrows, ymn = CooYmn, ymx = CooYmx,
                      ncols = CooNcols, xmn = CooXmn, xmx = CooXmx,
                      vals = Disease_times)
plot(rasterTimes, main = "Week of year plant became diseased")


```

\ 

The simulation above was run for `r numYears` years, with a time step of 1 week (i.e., 52 time steps), on a vineyard of `r nrc` x `r nrc` = `r nrc*nrc` plants. In the figure above, green squares are healthy plants at the end of the simulation, with the other colors indicating the time (week within the season) of that each plants became diseased: lighter colors indicate earlier disease times. I also set immigration of vectors from only 1 border. 

\ 

The figure below shows the number of cumulative infections over time for all six years

```{r, fig.cap = "Cumulative number of infections per week. Vertical dashed lines indicate the end of each year", fig.align = "center"}

## Vector of week number at the end of years, to produce vertical lines on ggplot
endOfYears <- data.frame(timeStep = Tmax*1:numYears)

## Vector of each time step (weeks)
weekVector <- data.frame(timeStep = 1:(Tmax*numYears))

## Round up infection times
finalInfectionTimes <- ceiling(Exp_times)

infectionTimesList <- vector("list", numYears)
for(y in 1:numYears){
  times.y <- finalInfectionTimes[,y]
  times.y <- times.y[times.y < Tmax]
  infCounts <- rle(sort(times.y))
  infectionTimesList[[y]] <- data.frame(timeStep = infCounts$values+(Tmax*(y-1)), 
                                        numInfections = infCounts$lengths,
                                        cumulInfections = cumsum(infCounts$lengths))
  ## Bug: 
  ## If there are no chronic infections, the number of cumulative infections doesn't go to zero at the start of the next year
  ## instead, cumulative infections go to zero at the time of the next infection.
  ## if() statement to fix the bug:
  if(all(Exp_times[,y] != 0)){
    infectionTimesList[[y]] <- rbind(c((Tmax*(y-1)), 0, 0), infectionTimesList[[y]])
  }
}

infectionTimes <- infectionTimesList %>% rbindlist() %>% as.data.frame() %>%
  ## Expand data set so that each time step is included explicitly
  right_join(., weekVector, by = "timeStep") %>%
  fill(cumulInfections) %>% # Replace NAs with previous non-NA value
  ## Replace NAs with 0
  ## Can replace NAs in cumulInfections with 0 now because these are just at the start of the time series
  replace_na(list(numInfections = 0, cumulInfections = 0))

infDynamicsPlot <- ggplot(data = infectionTimes, aes(x = timeStep, y = cumulInfections)) +
  geom_path(lwd = 1) +
  ## Add vertical lines indicating the end of each growing season/year
  geom_vline(data = endOfYears, aes(xintercept = timeStep), linetype = 2) +
  scale_x_continuous(name = "Weeks") +
  scale_y_continuous(name = "Cumulative number of latent infections",
                     sec.axis = sec_axis(~./numPlants, name = "Proportion of plants with latent infections")) +
  theme_bw(base_size=16) +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_rect(colour = "black"),
        panel.background = element_blank(),
        legend.position = "none") 

# ggsave("results/simulation_results/infection_dynamics_without_rouguing.jpg", plot = infDynamicsPlot,
#        width = 7, height = 7, units = "in")

infDynamicsPlot

```

\ 

#### Plot dynamics of in-field vector density

```{r, fig.align="center", fig.cap="In-field vector density over time"}

#### Beta values for each time step
plotRho_bt <- data.frame(rho_btVec,
                         week = 1:length(rho_btVec))

ggplot(data = plotRho_bt, aes(x = week, y = rho_btVec)) +
  geom_path(lwd = 1) +
  scale_x_continuous(name = "Week", limits = c(1,52), breaks = seq(1,52,by=5)) +
  scale_y_continuous(name = "In-field vector density") +
  theme_bw(base_size=16) +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_rect(colour = "black"),
        panel.background = element_blank(),
        legend.position = "none") 

```

\ 

#### Number of new infected plants scaled by in-field vector density

```{r, fig.align = "center", fig.cap = "Number of new infections scaled by vector density. Note, chronic infections were removed from figure"}

#### Add vector density to infection times data set
## rho_btVec is a vector of densities of length Tmax; as long as nrow(infectionTimes) is a multiple of Tmax, rho_btVec values will be recycled
infectionTimes$vectorDensity <- rho_btVec
infectionTimes$scaledInfections <- with(infectionTimes, numInfections/vectorDensity)

#### Remove chronic infections -- can be accomplished by removing the last week of each year
infectionTimes <- infectionTimes[!(infectionTimes$timeStep %in% endOfYears$timeStep),]

ggplot(data = infectionTimes, aes(x = timeStep, y = scaledInfections)) +
  geom_path(lwd = 1) +
  geom_vline(data = endOfYears, aes(xintercept = timeStep), linetype = 2) +
  scale_x_continuous(name = "Week") +
  scale_y_continuous(name = "Number of new latent infections per vector") +
  theme_bw(base_size=16) +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_rect(colour = "black"),
        panel.background = element_blank(),
        legend.position = "none") 

```

\ 

#### Distribution of Infectious times

```{r, fig.align='center', fig.cap='Distribution of times (week within season) that plants became Infectious'}

plotInfTimes <- data.frame(infTimes = Inf_times[Inf_times < Tmax])

ggplot(plotInfTimes, aes(x = infTimes)) +
  geom_histogram(binwidth = 1) +
  scale_x_continuous(name = "Infection times (weeks)") +
  scale_y_continuous(name = "Frequency") +
  theme_bw(base_size=16) +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_rect(colour = "black"),
        panel.background = element_blank(),
        legend.position = "none") 


```

\ 

#### Distribution of Disease times
```{r, fig.align='center', fig.cap='Distribution of times (week within season) that plants became Diseased'}

plotDiseaseTimes <- data.frame(dTimes = Disease_times[Disease_times < Tmax])

ggplot(plotDiseaseTimes, aes(x = dTimes)) +
  geom_histogram(binwidth = 1) +
  scale_x_continuous(name = "Disease times (weeks)") +
  scale_y_continuous(name = "Frequency") +
  theme_bw(base_size=16) +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_rect(colour = "black"),
        panel.background = element_blank(),
        legend.position = "none") 

```

\ 

#### Dynamics of in-field vector natural infectivity

```{r, fig.align="center", fig.cap="In-field vector infectivity over time"}

#### Kappa values for each time step
plotKappa <- data.frame(kappa = c(kappaMatrix),
                          week = 1:(Tmax*numYears))

ggplot(data = plotKappa, aes(x = week, y = kappa)) +
  geom_path(lwd = 1) +
  geom_vline(data = endOfYears, aes(xintercept = timeStep), linetype = 2) +
  scale_x_continuous(name = "Week") +
  scale_y_continuous(name = "Proportion of in-field vectors infectious") +
  theme_bw(base_size=16) +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_rect(colour = "black"),
        panel.background = element_blank(),
        legend.position = "none") 

```


#### Dynamics of external and secondary infection rates

```{r, fig.align="center", fig.cap="Mean external infection rates over time"}

#### Average external infection rate (epsilon) over susceptible plants at each time step
plotEpsilon <- data.frame(meanEpsilon = colMeans(epsilonMatrix, na.rm = TRUE),
                          week = seq(1, 52, length.out = Tmax))

ggplot(data = plotEpsilon, aes(x = week, y = meanEpsilon)) +
  geom_path(lwd = 1) +
  scale_x_continuous(name = "Week", limits = c(1,52), breaks = seq(1,52,by=5)) +
  scale_y_continuous(name = "Mean epsilon") +
  theme_bw(base_size=16) +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_rect(colour = "black"),
        panel.background = element_blank(),
        legend.position = "none") 

```

\ 

```{r, fig.align="center", fig.cap="Secondary infection rate over time"}

#### Beta values for each time step
plotBeta <- data.frame(betaVec,
                       week = seq(1,52, length.out = length(betaVec)))

ggplot(data = plotBeta, aes(x = week, y = betaVec)) +
  geom_path(lwd = 1) +
  scale_x_continuous(name = "Week", limits = c(1,52), breaks = seq(1,52,by=5)) +
  scale_y_continuous(name = "Beta") +
  theme_bw(base_size=16) +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_rect(colour = "black"),
        panel.background = element_blank(),
        legend.position = "none") 

```

\ 

Next steps:  
1. The parameter values are totally made up at this point. I/we would need to think about the time steps and what appropriate parameter values should look like.  
2. I'm sure I could improve upon the damped sine wave for vector density. This is a "first pass". Suggestions would be great.  
3. Running different simulations that we talked about in the last meeting: forcing $\epsilon$ and $\beta$ to be zero, respectively, and removing the first and second generations of immigrating vectors.